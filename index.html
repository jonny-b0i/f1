<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Mini F1 Monaco</title>
<style>
html, body { margin:0; padding:0; height:100%; background:#071225; color:#e8f1f7; font-family:Arial,sans-serif; }
canvas { display:block; margin:auto; background:#062b40; border-radius:8px; box-shadow:0 6px 18px rgba(0,0,0,.6); }
#hud { width:350px; position:absolute; top:10px; left:10px; background:linear-gradient(180deg,#041220,#062a3a); padding:12px; border-radius:8px; font-size:14px; }
#hud div { margin-bottom:6px; }
</style>
</head>
<body>
<canvas id="game" width="1200" height="700"></canvas>
<div id="hud">
  <div>Battery: <span id="battery">100%</span></div>
  <div>DRS: <span id="drs">OFF</span></div>
  <div>Damage: <span id="damage">0%</span></div>
  <div>Penalties: <span id="penalties">0</span></div>
  <div>Lap: <span id="lap">1</span></div>
  <div>Speed: <span id="speed">0</span> km/h</div>
  <div>Position: <span id="pos">1</span>/<span id="total">1</span></div>
</div>
<script>
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

// Monaco-like track using waypoints (simplified)
// Format: [{x,y}]
const TRACK = [
{ x:600, y:50 }, { x:1000, y:100 }, { x:1100, y:350 }, { x:1000, y:600 },
{ x:600, y:650 }, { x:200, y:600 }, { x:100, y:350 }, { x:200, y:100 }
];
// DRS zones defined as segments along track indices
const DRS_ZONES = [[0,1],[4,5]];

// Player
let player = { x:TRACK[0].x, y:TRACK[0].y, angle:0, vel:0, damage:0, penalties:0, lap:1, battery:100, drs:false, inPit:false, pitTimer:0, name:'Player', targetIndex:1 };
const bots = [];
for(let i=0;i<3;i++){ const t=TRACK[0]; bots.push({ x:t.x+Math.random()*10-5, y:t.y+Math.random()*10-5, angle:0, vel:0, damage:0, penalties:0, lap:1, battery:50, drs:false, inPit:false, pitTimer:0, name:'Bot'+(i+1), targetIndex:1}); }

// Input
const input = {up:false, down:false, left:false, right:false, ers:false, drs:false};
window.addEventListener('keydown', e=>{
  if(['ArrowUp','w'].includes(e.key)) input.up=true;
  if(['ArrowDown','s'].includes(e.key)) input.down=true;
  if(['ArrowLeft','a'].includes(e.key)) input.left=true;
  if(['ArrowRight','d'].includes(e.key)) input.right=true;
  if(e.key==='e'||e.key==='E') input.ers=true;
  if(e.key==='d'||e.key==='D') input.drs=true;
});
window.addEventListener('keyup', e=>{
  if(['ArrowUp','w'].includes(e.key)) input.up=false;
  if(['ArrowDown','s'].includes(e.key)) input.down=false;
  if(['ArrowLeft','a'].includes(e.key)) input.left=false;
  if(['ArrowRight','d'].includes(e.key)) input.right=false;
  if(e.key==='e'||e.key==='E') input.ers=false;
  if(e.key==='d'||e.key==='D') input.drs=false;
});

// Utils
function distance(a,b){return Math.hypot(a.x-b.x,a.y-b.y);}
function angleToTarget(car,target){return Math.atan2(target.y-car.y,target.x-car.x);}
function isInDRSZone(car){return DRS_ZONES.some(z=>{ return car.targetIndex>=z[0] && car.targetIndex<=z[1];});}

// Update car
function updateCar(car,dt,inp){
  if(car.inPit){ car.pitTimer-=dt; if(car.pitTimer<=0){car.inPit=false; car.damage=0; car.battery=100; car.vel=0;} return; }

  // Steering
  const target = TRACK[car.targetIndex];
  let desired = angleToTarget(car,target);
  let diff = desired-car.angle; while(diff>Math.PI) diff-=2*Math.PI; while(diff<-Math.PI) diff+=2*Math.PI;
  const steerSpeed = 0.03*(5/(car.vel+1)); // slower at high speed
  car.angle += Math.max(-steerSpeed, Math.min(steerSpeed,diff));

  // Acceleration
  if(inp.up) car.vel += 0.1*dt*60; else car.vel -= 0.05*dt*60;
  car.vel = Math.max(0, Math.min(8, car.vel)); // max speed ~8 units/frame

  // ERS
  if(inp.ers && car.battery>0){ car.vel += 0.2; car.battery -= 20*dt; if(car.battery<0) car.battery=0; } else { car.battery+=10*dt; if(car.battery>100) car.battery=100; }

  // DRS
  car.drs = inp.drs && isInDRSZone(car);
  if(car.drs) car.vel += 0.15;

  // Movement
  car.x += Math.cos(car.angle)*car.vel;
  car.y += Math.sin(car.angle)*car.vel;

  // Waypoint reached
  if(distance(car, target)<20){ car.targetIndex=(car.targetIndex+1)%TRACK.length; if(car.targetIndex===0) car.lap++; }

  // Auto pit
  if(car.damage>50 && !car.inPit){ car.inPit=true; car.pitTimer=2.5+Math.random()*0.7; car.vel=0; }
}

// Bot AI
function updateBot(bot,dt){
  updateCar(bot,dt,{up:true,ers:false,drs:isInDRSZone(bot)});
}

// Collision
function handleCollisions(){
  const cars=[player,...bots];
  for(let i=0;i<cars.length;i++){
    for(let j=i+1;j<cars.length;j++){
      const a=cars[i], b=cars[j];
      const d=distance(a,b);
      if(d<20){ const impact=2; a.damage+=impact; b.damage+=impact; a.penalties++; b.penalties++; }
    }
  }
}

// Draw
function drawCar(c){
  ctx.save(); ctx.translate(c.x,c.y); ctx.rotate(c.angle);
  ctx.fillStyle=c.name.startsWith('Bot')?'#f44':'#5fe';
  ctx.fillRect(-12,-8,24,16);
  if(c.drs){ ctx.fillStyle='yellow'; ctx.fillRect(-12,6,10,3); }
  ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(-12,-16,24,4);
  ctx.fillStyle='red'; ctx.fillRect(-12,-16,24*(1-c.damage/100),4);
  ctx.restore();
}

function render(){
  ctx.clearRect(0,0,W,H);
  // Track
  ctx.strokeStyle='#2b4c66'; ctx.lineWidth=TRACK.length/2; ctx.beginPath();
  for(let i=0;i<TRACK.length;i++){ const p=TRACK[i]; if(i===0) ctx.moveTo(p.x,p.y); else ctx.lineTo(p.x,p.y);}
  ctx.closePath(); ctx.stroke();
  // Cars
  [player,...bots].forEach(c=>drawCar(c));
  // HUD
  document.getElementById('battery').textContent=Math.round(player.battery)+'%';
  document.getElementById('drs').textContent=player.drs?'OPEN':'OFF';
  document.getElementById('damage').textContent=Math.round(player.damage)+'%';
  document.getElementById('penalties').textContent=player.penalties;
  document.getElementById('lap').textContent=player.lap;
  document.getElementById('speed').textContent=Math.round(player.vel*40);
  const rankList=[player,...bots].sort((a,b)=>b.lap-a.lap || b.targetIndex-a.targetIndex);
  document.getElementById('pos').textContent=rankList.indexOf(player)+1;
  document.getElementById('total').textContent=rankList.length;
}

// Game loop
let last=performance.now();
function loop(t){
  const dt=Math.min(0.05,(t-last)/1000); last=t;
  updateCar(player,dt,input);
  bots.forEach(b=>updateBot(b,dt));
  handleCollisions();
  render();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
